#!/usr/bin/env node

/**
 * Quality Gates - Validation Before Implementation
 *
 * Multi-stage validation pipeline:
 * - Security audit
 * - Test coverage check
 * - Performance validation
 * - Style consistency
 * - Dependency audit
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class QualityGatePipeline {
  constructor() {
    this.gates = [
      { name: 'Security', check: this.securityGate.bind(this), critical: true },
      { name: 'Test Coverage', check: this.testCoverageGate.bind(this), critical: true },
      { name: 'Performance', check: this.performanceGate.bind(this), critical: false },
      { name: 'Code Style', check: this.styleGate.bind(this), critical: false },
      { name: 'Dependencies', check: this.dependencyGate.bind(this), critical: false }
    ];
  }

  /**
   * Run all quality gates
   */
  async validate(code, options = {}) {
    console.log('üö¶ Running Quality Gates...\n');

    const results = [];
    let criticalFailures = 0;

    for (const gate of this.gates) {
      console.log(`${'='.repeat(80)}`);
      console.log(`Gate: ${gate.name} ${gate.critical ? 'üî¥ CRITICAL' : 'üü° NON-CRITICAL'}`);
      console.log('='.repeat(80));

      try {
        const result = await gate.check(code, options);

        results.push({
          gate: gate.name,
          ...result
        });

        if (result.passed) {
          console.log(`‚úÖ ${gate.name}: PASSED`);
        } else {
          console.log(`‚ùå ${gate.name}: FAILED`);
          console.log(`   Reason: ${result.reason}`);

          if (result.autoFixable) {
            console.log(`   üîß Auto-fix available`);
            if (options.autoFix) {
              console.log(`   üîÑ Applying auto-fix...`);
              code = result.fix(code);
              console.log(`   ‚úÖ Auto-fix applied`);
            }
          }

          if (gate.critical) {
            criticalFailures++;
          }
        }

        if (result.warnings && result.warnings.length > 0) {
          console.log(`   ‚ö†Ô∏è  Warnings:`);
          result.warnings.forEach(w => console.log(`      - ${w}`));
        }

        console.log();
      } catch (error) {
        console.error(`‚ùå Gate ${gate.name} error:`, error.message);
        results.push({
          gate: gate.name,
          passed: false,
          error: error.message
        });

        if (gate.critical) {
          criticalFailures++;
        }
      }
    }

    const summary = {
      passed: criticalFailures === 0,
      criticalFailures,
      totalGates: this.gates.length,
      results
    };

    this.printSummary(summary);

    return summary;
  }

  /**
   * Security Gate - Check for vulnerabilities
   */
  async securityGate(code, options) {
    const issues = {
      critical: [],
      high: [],
      medium: [],
      low: []
    };

    // SQL Injection
    if (code.match(/SELECT.*FROM.*WHERE.*['"]?\$\{|query\(`.*\$\{/gi)) {
      issues.critical.push('Potential SQL injection');
    }

    // XSS
    if (code.match(/innerHTML\s*=|dangerouslySetInnerHTML/gi)) {
      issues.high.push('Potential XSS via innerHTML');
    }

    // Hardcoded secrets
    if (code.match(/(password|secret|api_key|token)\s*=\s*['"][^'"]{8,}['"]/gi)) {
      issues.critical.push('Hardcoded secrets detected');
    }

    // Insecure random
    if (code.match(/Math\.random\(\)/g)) {
      issues.medium.push('Math.random() is not cryptographically secure');
    }

    // Eval usage
    if (code.match(/\beval\(/g)) {
      issues.high.push('Use of eval() is dangerous');
    }

    // Command injection
    if (code.match(/exec\(|spawn\(.*\$\{|system\(/gi)) {
      issues.high.push('Potential command injection');
    }

    const totalIssues = Object.values(issues).flat().length;

    if (issues.critical.length > 0) {
      return {
        passed: false,
        reason: `${issues.critical.length} critical security issues`,
        issues,
        autoFixable: false
      };
    }

    if (issues.high.length > 0) {
      return {
        passed: false,
        reason: `${issues.high.length} high-severity issues`,
        issues,
        autoFixable: false
      };
    }

    return {
      passed: true,
      issues,
      warnings: [...issues.medium, ...issues.low]
    };
  }

  /**
   * Test Coverage Gate - Ensure adequate testing
   */
  async testCoverageGate(code, options) {
    const minCoverage = options.minCoverage || 80;

    // Heuristic analysis
    const codeLines = code.split('\n').filter(l => l.trim() && !l.trim().startsWith('//')).length;
    const testLines = (code.match(/test\(|it\(|describe\(/g) || []).length * 5; // Estimate

    const estimatedCoverage = Math.min(100, (testLines / codeLines) * 100);

    if (estimatedCoverage < minCoverage) {
      return {
        passed: false,
        reason: `Estimated coverage ${Math.round(estimatedCoverage)}% < ${minCoverage}%`,
        autoFixable: true,
        fix: (code) => {
          // In real implementation, would generate additional tests
          return code + '\n\n// TODO: Add more tests to reach ' + minCoverage + '% coverage';
        }
      };
    }

    return {
      passed: true,
      coverage: Math.round(estimatedCoverage),
      message: `Estimated coverage: ${Math.round(estimatedCoverage)}%`
    };
  }

  /**
   * Performance Gate - Check for common performance issues
   */
  async performanceGate(code, options) {
    const issues = [];

    // Synchronous operations in async code
    if (code.match(/readFileSync|writeFileSync/) && code.match(/async function/)) {
      issues.push('Sync file operations in async function');
    }

    // N+1 queries pattern
    if (code.match(/for.*await.*query|forEach.*await.*query/gi)) {
      issues.push('Potential N+1 query problem');
    }

    // Missing pagination
    if (code.match(/findAll|find\(\{\}\)|select \* from/gi) && !code.match(/limit|take|paginate/gi)) {
      issues.push('Query without pagination');
    }

    // Large array operations
    if (code.match(/\.map\(.*\.map\(|\.filter\(.*\.filter\(/g)) {
      issues.push('Nested array operations (O(N¬≤))');
    }

    return {
      passed: issues.length === 0,
      reason: issues.length > 0 ? 'Performance issues detected' : null,
      issues,
      warnings: issues
    };
  }

  /**
   * Code Style Gate - Consistency checks
   */
  async styleGate(code, options) {
    const issues = [];

    // Mixed quotes
    const singleQuotes = (code.match(/'/g) || []).length;
    const doubleQuotes = (code.match(/"/g) || []).length;
    const backticks = (code.match(/`/g) || []).length;

    if (singleQuotes > 0 && doubleQuotes > 0 && Math.abs(singleQuotes - doubleQuotes) > 10) {
      issues.push('Inconsistent quote style');
    }

    // Missing semicolons (if using semicolons elsewhere)
    const withSemicolon = (code.match(/;$/gm) || []).length;
    const statements = (code.match(/\n/g) || []).length;

    if (withSemicolon > statements * 0.3 && withSemicolon < statements * 0.7) {
      issues.push('Inconsistent semicolon usage');
    }

    // Long lines
    const longLines = code.split('\n').filter(l => l.length > 120).length;
    if (longLines > 5) {
      issues.push(`${longLines} lines exceed 120 characters`);
    }

    return {
      passed: true, // Style is non-critical
      issues,
      warnings: issues
    };
  }

  /**
   * Dependency Gate - Check for security issues in dependencies
   */
  async dependencyGate(code, options) {
    const issues = [];

    // Check for outdated package patterns
    if (code.match(/require\(['"](?:request|node-uuid)['"]\)/)) {
      issues.push('Deprecated packages detected (request, node-uuid)');
    }

    // Check for known vulnerable patterns
    if (code.match(/xml2js|xmldom/) && !code.match(/defenselyIgnoreResolveError/)) {
      issues.push('XML parsing without security configuration');
    }

    return {
      passed: issues.length === 0,
      issues,
      warnings: issues
    };
  }

  /**
   * Print summary
   */
  printSummary(summary) {
    console.log('\n' + '='.repeat(80));
    console.log('QUALITY GATES SUMMARY');
    console.log('='.repeat(80));

    console.log(`\nTotal Gates: ${summary.totalGates}`);
    console.log(`Passed: ${summary.results.filter(r => r.passed).length}`);
    console.log(`Failed: ${summary.results.filter(r => !r.passed).length}`);
    console.log(`Critical Failures: ${summary.criticalFailures}`);

    console.log(`\nOverall Status: ${summary.passed ? '‚úÖ APPROVED' : '‚ùå BLOCKED'}`);

    if (!summary.passed) {
      console.log('\nüö® CRITICAL ISSUES MUST BE FIXED BEFORE IMPLEMENTATION');
    }

    console.log('='.repeat(80) + '\n');
  }
}

// ============================================================================
// CLI Interface
// ============================================================================

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0 || args[0] === '--help') {
    console.log(`
Quality Gates - Validation Before Implementation

Usage:
  quality-gates <file>
  quality-gates --code "<code>"

Options:
  --auto-fix         Apply automatic fixes where possible
  --min-coverage N   Minimum test coverage (default: 80)

Gates:
  üî¥ Security         Check for vulnerabilities (CRITICAL)
  üî¥ Test Coverage    Ensure adequate testing (CRITICAL)
  üü° Performance      Check for performance issues
  üü° Code Style       Ensure consistency
  üü° Dependencies     Check for security issues

Examples:
  quality-gates src/auth.ts
  quality-gates --code "const x = 1"
  quality-gates src/api.ts --auto-fix --min-coverage 90
`);
    process.exit(0);
  }

  let code = '';
  const options = {
    autoFix: args.includes('--auto-fix'),
    minCoverage: 80
  };

  // Parse min-coverage option
  const minCoverageIndex = args.indexOf('--min-coverage');
  if (minCoverageIndex !== -1 && args[minCoverageIndex + 1]) {
    options.minCoverage = parseInt(args[minCoverageIndex + 1]);
  }

  // Get code from file or --code argument
  if (args[0] === '--code') {
    code = args[1];
  } else {
    const filepath = args[0];
    if (!fs.existsSync(filepath)) {
      console.error(`‚ùå File not found: ${filepath}`);
      process.exit(1);
    }
    code = fs.readFileSync(filepath, 'utf8');
  }

  const pipeline = new QualityGatePipeline();

  try {
    const result = await pipeline.validate(code, options);

    if (result.passed) {
      console.log('‚úÖ All critical gates passed - ready for implementation');
      process.exit(0);
    } else {
      console.error('‚ùå Quality gates failed - fix issues before proceeding');
      process.exit(1);
    }
  } catch (error) {
    console.error('‚ùå Quality gate error:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

module.exports = { QualityGatePipeline };
