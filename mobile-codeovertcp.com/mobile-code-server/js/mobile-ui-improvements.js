// Mobile UI Improvements for code-server
// Generated by UltraThink v6.1

class MobileUIImprovements {
  constructor() {
    this.sidebarVisible = false;
    this.initSidebarToggle();
    this.initSwipeGestures();
  }

  initSidebarToggle() {
    const toggle = document.createElement('button');
    toggle.innerHTML = '☰';
    // Removed inline styles as requested by user.
    // The button will now be invisible or styled purely by external CSS if needed.
    // toggle.style.cssText = 'position: fixed; top: 10px; left: 10px; z-index: 10000; width: 44px; height: 44px; font-size: 18px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;';
    toggle.id = 'mobile-sidebar-toggle';
    toggle.className = 'mobile-sidebar-toggle'; // For CSS targeting

    toggle.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.toggleSidebar();
    });
    document.body.appendChild(toggle);
  }

  toggleSidebar() {
    console.log('Toggling sidebar...');

    // Method 1: Simulate Ctrl+B (Command+B)
    // We dispatch on document.body to avoid "i.hasAttribute is not a function" error in VS Code
    // which happens when dispatching on document.
    try {
      const keyEvent = new KeyboardEvent('keydown', {
        key: 'b',
        code: 'KeyB',
        ctrlKey: true,
        metaKey: true, // For Mac support
        bubbles: true,
        cancelable: true,
        composed: true, // Important for Shadow DOM
        view: window
      });
      document.body.dispatchEvent(keyEvent);
      console.log('Dispatched Ctrl+B on document.body');
      return; // Assume it worked if no error
    } catch (e) {
      console.error('Failed to dispatch keyboard event', e);
    }

    // Method 2: Click the explorer icon if visible (fallback)
    const selectors = [
      // VS Code 1.90+ Activity Bar
      '.activitybar .action-label.codicon-files',
      '.activitybar .action-label.codicon-explorer',

      // Older VS Code / Code Server
      '.monaco-action-bar .action-item.checked .action-label',
      '[aria-label="Explorer"]',
      '[title="Explorer"]',

      // Generic fallback
      '.activitybar .action-item.checked'
    ];

    let found = false;
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (element) {
        console.log('Found sidebar element:', selector, element);
        const clickEvent = new MouseEvent('click', {
          view: window,
          bubbles: true,
          cancelable: true
        });
        element.dispatchEvent(clickEvent);
        found = true;
        break;
      }
    }

    if (!found) {
      console.warn('No sidebar element found to click. Selectors tried:', selectors);
    }
  }
  initSwipeGestures() {
    let touchStartX = 0;
    let touchStartY = 0;

    document.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const deltaX = touchEndX - touchStartX;

      // Swipe right to open sidebar
      if (deltaX > 50 && Math.abs(touchEndY - touchStartY) < 100) {
        // Only if starting from the edge
        if (touchStartX < 30) {
          this.toggleSidebar();
        }
      }

      // Swipe left to close sidebar
      if (deltaX < -50 && Math.abs(touchEndY - touchStartY) < 100) {
        // If sidebar is likely open (we can't easily know state, but trying to close is safe)
        // We can try to click the sidebar toggle again or just rely on the toggle logic
        // For now, let's assume toggleSidebar handles the state or we just toggle it.
        // A better check would be to see if the sidebar DOM element is visible, but that varies.
        // Let's just call toggleSidebar() as it acts as a toggle.
        // To avoid accidental closes, maybe we restrict where the swipe starts?
        // Let's assume swipe left from anywhere on the right side closes it.
        if (touchStartX > window.innerWidth - 100 || touchStartX > 200) {
          this.toggleSidebar();
        }
      }
    }, { passive: true });
  }

  initTerminalScrolling() {
    // Two-finger scrolling for xterm.js using WheelEvent simulation
    // This is more robust than scrollTop as it triggers xterm's internal scroll handlers
    let lastTouchY = 0;
    let isScrolling = false;

    document.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        lastTouchY = e.touches[0].clientY;
        isScrolling = true;
      } else {
        isScrolling = false;
      }
    }, { passive: true, capture: true }); // Capture to see it first

    document.addEventListener('touchmove', (e) => {
      if (!isScrolling || e.touches.length !== 2) return;

      const currentTouchY = e.touches[0].clientY;
      const deltaY = lastTouchY - currentTouchY;
      lastTouchY = currentTouchY;

      // Find if we are over a terminal
      const target = e.target;
      const terminal = target.closest('.xterm-viewport') || target.closest('.xterm-screen');

      if (terminal) {
        // Simulate a mouse wheel event
        // DeltaY needs to be scaled. 
        // Positive deltaY means scrolling DOWN (finger moves UP)
        // Negative deltaY means scrolling UP (finger moves DOWN)

        const wheelEvent = new WheelEvent('wheel', {
          deltaY: deltaY * 2, // Multiplier for speed
          deltaMode: 0, // DOM_DELTA_PIXEL
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY
        });

        terminal.dispatchEvent(wheelEvent);
        console.log('Dispatched WheelEvent:', deltaY);

        // Prevent default page scroll/zoom
        if (e.cancelable) e.preventDefault();
      }
    }, { passive: false, capture: true }); // Capture and non-passive to prevent default

    document.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) {
        isScrolling = false;
      }
    }, { passive: true, capture: true });

    console.log('Terminal two-finger scrolling initialized (WheelEvent + Capture)');
  }

  initMultiTouchGestures() {
    let touchStartTime = 0;
    let startTouches = 0;

    document.addEventListener('touchstart', (e) => {
      touchStartTime = Date.now();
      startTouches = e.touches.length;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
      const duration = Date.now() - touchStartTime;

      // Only trigger if tap was short (< 300ms)
      if (duration > 300) return;

      // 3-finger tap to open Command Palette
      // e.changedTouches contains the fingers that LEFT the screen
      // We check startTouches to see how many were pressed
      if (startTouches === 3) {
        console.log('3-finger tap detected: Opening Command Palette');
        this.openCommandPalette();
      }

      // 2-finger tap to Undo (Ctrl+Z)
      // We need to be careful not to trigger this on scroll end
      // But scroll usually takes longer than 300ms or has movement
      if (startTouches === 2) {
        console.log('2-finger tap detected: Undo');
        this.triggerUndo();
      }
    }, { passive: true });
  }

  openCommandPalette() {
    // Simulate F1 key press
    const keyEvent = new KeyboardEvent('keydown', {
      key: 'F1',
      code: 'F1',
      keyCode: 112,
      bubbles: true,
      cancelable: true,
      view: window
    });
    document.body.dispatchEvent(keyEvent);
  }

  triggerUndo() {
    // Simulate Ctrl+Z
    const keyEvent = new KeyboardEvent('keydown', {
      key: 'z',
      code: 'KeyZ',
      ctrlKey: true,
      metaKey: true, // For Mac
      bubbles: true,
      cancelable: true,
      view: window
    });
    document.activeElement.dispatchEvent(keyEvent);
  }

  initMobileToolbar() {
    const toolbar = document.createElement('div');
    toolbar.id = 'mobile-toolbar';
    toolbar.className = 'mobile-toolbar';

    const keys = [
      { label: 'ESC', code: 'Escape', key: 'Escape', keyCode: 27 },
      { label: 'TAB', code: 'Tab', key: 'Tab', keyCode: 9 },
      { label: '←', code: 'ArrowLeft', key: 'ArrowLeft', keyCode: 37 },
      { label: '↓', code: 'ArrowDown', key: 'ArrowDown', keyCode: 40 },
      { label: '↑', code: 'ArrowUp', key: 'ArrowUp', keyCode: 38 },
      { label: '→', code: 'ArrowRight', key: 'ArrowRight', keyCode: 39 },
      { label: 'CMD+P', action: 'quickOpen' },
      { label: 'CMD+S', action: 'save' },
      { label: 'GIT', action: 'git' },
      { label: 'TERM', action: 'terminal' },
      { label: '?', action: 'help' }
    ];

    keys.forEach(k => {
      const btn = document.createElement('button');
      btn.textContent = k.label;
      btn.className = 'mobile-toolbar-btn';

      // Prevent focus stealing
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent focus loss
        if (k.action) {
          this.handleToolbarAction(k.action);
        } else {
          this.simulateKey(k);
        }
        btn.classList.add('active');
      });

      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        btn.classList.remove('active');
      });

      toolbar.appendChild(btn);
    });

    document.body.appendChild(toolbar);
  }

  simulateKey(k) {
    const target = document.activeElement;
    const event = new KeyboardEvent('keydown', {
      key: k.key,
      code: k.code,
      keyCode: k.keyCode,
      which: k.keyCode,
      bubbles: true,
      cancelable: true,
      view: window
    });
    target.dispatchEvent(event);
  }

  handleToolbarAction(action) {
    if (action === 'quickOpen') {
      // Ctrl+P / Cmd+P
      this.dispatchKey('p', 'KeyP', true);
    } else if (action === 'save') {
      // Ctrl+S / Cmd+S
      this.dispatchKey('s', 'KeyS', true);
    } else if (action === 'git') {
      // Ctrl+Shift+G
      this.dispatchKey('g', 'KeyG', true, true);
    } else if (action === 'terminal') {
      // Ctrl+` (Backquote)
      this.dispatchKey('`', 'Backquote', true);
    } else if (action === 'help') {
      this.showWelcomeToast();
    }
  }

  dispatchKey(key, code, ctrl = false, shift = false) {
    const event = new KeyboardEvent('keydown', {
      key: key,
      code: code,
      ctrlKey: ctrl,
      metaKey: ctrl, // For Mac
      shiftKey: shift,
      bubbles: true,
      cancelable: true,
      view: window
    });
    document.activeElement.dispatchEvent(event);
  }

  showWelcomeToast() {
    if (document.getElementById('mobile-welcome-toast')) return;

    const toast = document.createElement('div');
    toast.id = 'mobile-welcome-toast';
    toast.className = 'mobile-welcome-toast';
    toast.innerHTML = `
          <div class="toast-header">
              <strong>Mobile Mode Active</strong>
              <button id="toast-close">×</button>
          </div>
          <div class="toast-content">
              <ul>
                  <li><strong>Gestures:</strong> 2-finger tap (Undo), 3-finger tap (Cmd Palette), Swipe Left (Close Sidebar)</li>
                  <li><strong>Toolbar:</strong> Use bottom bar for common keys.</li>
                  <li><strong>Scrolling:</strong> 2-finger drag in terminal.</li>
              </ul>
          </div>
      `;

    document.body.appendChild(toast);

    document.getElementById('toast-close').addEventListener('click', () => {
      toast.remove();
    });

    // Auto-hide after 10 seconds
    setTimeout(() => {
      if (toast.parentNode) toast.remove();
    }, 10000);
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    const ui = new MobileUIImprovements();
    ui.initTerminalScrolling();
    ui.initMultiTouchGestures();
    ui.initMobileToolbar();
    // Show welcome message after a short delay
    setTimeout(() => ui.showWelcomeToast(), 2000);

    // Register Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/mobile-assets/mobile-sw.js')
        .then(reg => console.log('Mobile SW registered', reg))
        .catch(err => console.error('Mobile SW failed', err));
    }
  });
} else {
  const ui = new MobileUIImprovements();
  ui.initTerminalScrolling();
  ui.initMultiTouchGestures();
  ui.initMobileToolbar();
  setTimeout(() => ui.showWelcomeToast(), 2000);

  // Register Service Worker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/mobile-assets/mobile-sw.js')
      .then(reg => console.log('Mobile SW registered', reg))
      .catch(err => console.error('Mobile SW failed', err));
  }
}

console.log('Mobile UI improvements loaded by UltraThink v6.7 (SW + PWA)');